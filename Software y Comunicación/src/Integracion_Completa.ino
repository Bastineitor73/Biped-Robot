#include <Arduino.h>
#include <ODriveTeensyCAN.h>
#include <FlexCAN_T4.h>        // <–– esto debe estar
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#define SCREEN_WIDTH  128
#define SCREEN_HEIGHT  64
#define OLED_RESET    -1          // Reset por software (GPIO no usado)
#define LOGO_WIDTH  84
#define LOGO_HEIGHT 52
#define BUZZER_PIN 6
#define PIN_BOTON 15

ODriveTeensyCAN odriveCAN(250000);  // Configuración CAN
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

//----------------CONFIGURACIÓN BUZZER-------------------------------
const int melody[] = { 262, 294, 330, 349, 330, 294, 262 };   // C4–D4–E4–F4–E4–D4–C4
const int noteDurations[] = { 200, 200, 200, 200, 200, 200, 400 };
const int melodyLength = sizeof(melody) / sizeof(melody[0]);

const int melodyHigh[] = { 392, 440, 494, 523, 494, 440, 392 };
const int noteDurationsHigh[] = { 150, 150, 150, 200, 150, 150, 300 };
const int melodyHighLength = sizeof(melodyHigh) / sizeof(melodyHigh[0]);


//-------------CONFIGURACIÓN MOTORES------------------------
// La estructura 'MotorConfig' define las propiedades de cada motor.
struct MotorConfig {          //Estructura de Configuración
  uint8_t node_id;            // Node ID en el bus CAN
  float pos_a;                // Posición 1 (vueltas)
  float pos_b;                // Posición 2 (vueltas)
  float current_target;       // Último objetivo enviado
  unsigned long lastMoveTime; // Último cambio
  unsigned long intervalo_ms; // Intervalo entre movimientos
  float last_position_deg;    // Última posición en grados
  float last_current_A;       // Última corriente
};

MotorConfig motores[] = {
  {0, 0.0, -1, 0.0, 0, 4000, 0.0, 0.0},        // Motor con Node ID 0
  {1, 0.0, 1, 0.0, 0, 4000, 0.0, 0.0},      // Motor con Node ID 1
  {2, 0.0, -0.7, 0.0, 0, 4000, 0.0, 0.0},       // Motor con Node ID 2
  {3, 0.0, 1, 0.0, 0, 4000, 0.0, 0.0},         // Motor con Node ID 3
  {4, 0.0, -0.35, 0, 0, 4000, 0,0},
  {5, 0.0, 0.4, 0, 0, 4000, 0,0}     
};

const int num_motores = sizeof(motores) / sizeof(MotorConfig);  //Se calcula automáticamente para saber cuántos motores hay.
const int espera = 700;


//-----------CONFIGURACIÓN DISPLAY-----------------------
struct frameOLA{
  char fecha[11];
  char hora[11];
  float accX, accY, accZ;
  float gyroX, gyroY, gyroZ;
  float magX, magY, magZ;
  float temp;
  float freq;
} data;
constexpr int Buff_len = 128;
char Buff[Buff_len];

const unsigned char PROGMEM logo[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x09, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x6c, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xdf, 0x00, 0x00, 0x00, 0x03, 0xce, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0x1c, 0x00, 0x00, 0x0f, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x9f, 0x10, 0x0f, 0xc7, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x9e, 0x1f, 0x3f, 0x97, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xbc, 0x9e, 0x3f, 0xb3, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xb9, 0xde, 0xbf, 0x3b, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xb3, 0xdd, 0x9f, 0x79, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xa7, 0xd9, 0xdf, 0x7d, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xdb, 0xde, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xd3, 0xde, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc7, 0xec, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};







//-------------------BOTONES E IMU-----------------
bool modoIMU = false;               // false: muestra imagen, true: muestra datos
bool lastNivel = HIGH;             // Para detectar flanco
bool ignorarPrimerCambio = true;   // Para evitar falsos positivos al arranque
unsigned long tUltimoCambio = 0;
const unsigned long DEBOUNCE_MS = 150;



// ------------VARIABLES DE CONTROL DE ESTADOS----------------
enum Estado { MENU, EJECUTANDO, DETENIENDO };  // Se define un 'enum' para los estados del programa (código más legible)
Estado estado = MENU;
char rutina_seleccionada = 0;
bool detener_rutina = false;    // Bandera para indicar si se debe detener la rutina actual.

void setup() {
  Serial.begin(115200);
  Serial2.begin(115200);         // UART2 (pines 7-8)
  while (!Serial);
  while (!Serial2);
  Wire1.begin();                  // inicia bus I²C en pins 17/16
  Wire1.setClock(400000);         // 400 kHz (rápido y estable)

  pinMode(PIN_BOTON, INPUT_PULLUP);  // Botón con lógica inversa (LOW = presionado)

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // dirección 0x3C
    while (true) {
      // Si falla, parpadea el LED integrado
      digitalToggle(LED_BUILTIN);
      delay(200);
    }
  }

  //Sonrisa inicial
  display.clearDisplay();
  display.drawBitmap(0,0,logo,128,64,WHITE);
  display.display();


  bool ejesOk[num_motores] = {false};
  bool errorMostrado[num_motores] = {false};

  //------ LÓGICA DE INICIALIZACIÓN Y CHEQUEO DE MOTORES ----------
  while (true) {                  // Bucle principal para asegurar que todos los motores estén en el estado correcto.
    int motoresPendientes = 0;
    for (int i = 0; i < num_motores; i++) {
      if (ejesOk[i]) continue;      // Si este motor ya está OK, salta al siguiente.
      odriveCAN.RunState(motores[i].node_id,8);  // Envía un comando CAN (id=8) para poner el motor modo closed-loop control
      uint32_t axisError = 0;
      uint8_t estadoActual = 0;
      bool ok = false;
      unsigned long start = millis();
      while (millis() - start < 1200) {
        CAN_message_t msg;
        // Procesa los mensajes CAN entrantes.
        while (odriveCAN.ReadMsg(msg)) {
          uint8_t node_id = (msg.id >> 5);
          if (node_id == motores[i].node_id &&
              (msg.id & 0x1F) == ODriveTeensyCAN::CMD_ID_ODRIVE_HEARTBEAT_MESSAGE) {
            HeartbeatMsg_t hb;
            odriveCAN.Heartbeat(hb, msg);
            axisError = hb.axisError;
            estadoActual = hb.currentState;
            if (axisError == 0 && estadoActual == 8) {
              ok = true;
              break;
            }
          }
        }
        if (ok) break;
        delay(10);
      }

      if (ok) {
        ejesOk[i] = true;
        Serial.print("Axis ");
        Serial.print(motores[i].node_id);
        Serial.println(" en modo cerrado OK.");
      } else {
        motoresPendientes++;
        if (!errorMostrado[i]) {
          Serial.print("ERROR: Axis "); Serial.print(motores[i].node_id);
          Serial.print(" NO entró en lazo cerrado (estado actual: ");
          Serial.print(estadoActual); Serial.print("). axisError: 0x");
          Serial.println(axisError, HEX);
          errorMostrado[i] = true;
        }
      }
      
    }
    imprimirHeartbeats();

    if (motoresPendientes == 0) break; // Todos OK, salimos del bucle
    delay(1000); // Espera antes de reintentar (silenciosamente)
  }

  Serial.println("Sistema iniciado.");
  Serial.println("Seleccione un modo:");
  Serial.println("[1] Axis Tests");
  Serial.println("[2] Walking On Sunshine");
  Serial.println("Para detener una rutina en ejecución, presione [s] y Enter.");
}


void loop() {
  //leerDatosCAN();
  leerErroresCAN();

  size_t n = Serial2.readBytesUntil('\n', Buff, Buff_len - 1);
  if (n > 0) {
    Buff[n] = '\0';
  } else {
    Buff[0] = '\0';
  }


  if (estado == MENU) {
    if (Serial.available() > 0) {
      char c = Serial.read();
      if (c == '1') {
        rutina_seleccionada = '1';
        estado = EJECUTANDO;
      } else if (c == '2') {
        rutina_seleccionada = '2';
        estado = EJECUTANDO;
      } else if (c == '3'){
        rutina_seleccionada = '3';
        estado = EJECUTANDO;
      }
    }
  }
  else if (estado == EJECUTANDO) {
    detener_rutina = false;
    if (rutina_seleccionada == '1') {
      playMelody(); 
      Rutina_A();
    } 
    else if (rutina_seleccionada == '2') {
      playHighMelody();
      Rutina_B();
    }

    // Al terminar, volver a posiciones originales
    Serial.println(">> Volviendo a posición original...");
    delay(200);
    moverMotoresAPosicionInicial();
    estado = MENU;
    rutina_seleccionada = 0;
    Serial.println(" ");
    Serial.println("Seleccione un modo:");
    Serial.println("[1] Axis Tests");
    Serial.println("[2] Walking On Sunshine");
    Serial.println("Para detener una rutina en ejecución, presione [s] y Enter.");
  }
  delay(10);
}

// Rutina A: Pero chequea si hay stop
void Rutina_A() {
  Serial.println(">> Ejecutando Axis Tests...");
  for (int m = 0; m < num_motores; m++) {
    leerErroresCAN();
    if (checkearStop()) return;
    odriveCAN.SetPosition(motores[m].node_id, motores[m].pos_a);
    esperarConInterrupcion(espera);
    if (checkearStop()) return;
    odriveCAN.SetPosition(motores[m].node_id, motores[m].pos_b);
    esperarConInterrupcion(espera);
    if (checkearStop()) return;
    odriveCAN.SetPosition(motores[m].node_id, motores[m].pos_a);
    esperarConInterrupcion(espera);
    
  }
  //Serial.println(">> Modo completado.");
}

// Rutina B: Simular caminata
void Rutina_B() {
  Serial.println(">> Ejecutando Walking On Sunshine...");
  for (int contador = 0; contador < 20; contador++){
    //Mover Pierna Izquierda
    odriveCAN.SetPosition(motores[0].node_id, motores[0].pos_b);  // Posición objetivo
    esperarConInterrupcion(100);
    odriveCAN.SetPosition(motores[2].node_id, motores[2].pos_b);  // Posición objetivo
    esperarConInterrupcion(800);
    odriveCAN.SetPosition(motores[0].node_id, 1);  // Regreso a inicial
    esperarConInterrupcion(20);
    odriveCAN.SetPosition(motores[2].node_id, motores[2].pos_a);  // Regreso a inicial

    esperarConInterrupcion(10);

    //Mover Pierna Derecha
    odriveCAN.SetPosition(motores[1].node_id, motores[1].pos_b);  // Posición objetivo
    esperarConInterrupcion(100);
    odriveCAN.SetPosition(motores[3].node_id, motores[3].pos_b);  // Posición objetivo
    esperarConInterrupcion(800);
    odriveCAN.SetPosition(motores[1].node_id, -1);  // Regreso a inicial
    esperarConInterrupcion(20);
    odriveCAN.SetPosition(motores[3].node_id, motores[3].pos_a);  // Regreso a inicial
  }
  esperarConInterrupcion(1000);
  //Serial.println(">> Modo completado");
}

void esperarConInterrupcion(unsigned long ms) {
  unsigned long start = millis();
  while (millis() - start < ms) {
    if (Serial.available() > 0 && Serial.read() == 's') {
      Serial.println("Rutina detenida por el usuario.");
      detener_rutina = true;
      break;
    }
    delay(10);  // Evita saturar el micro
  }
}

bool checkearStop() {
  if (detener_rutina) {
    Serial.println("Deteniendo rutina, saliendo...");
    return true;
  }
  return false;
}

// Mueve todos los motores a pos_a (posición original)
void moverMotoresAPosicionInicial() {
  const int repeticiones = 5;
  const int intervalo = 20;  // ms entre cada repetición (debe ser menor que el watchdog timeout)

  for (int r = 0; r < repeticiones; r++) {
    for (int i = 0; i < num_motores; i++) {
      odriveCAN.SetPosition(motores[i].node_id, motores[i].pos_a);
    }
    delay(intervalo);
  }
}


void leerErroresCAN() {
  CAN_message_t msg;
  while (odriveCAN.ReadMsg(msg)) {
    uint8_t node_id = (msg.id >> 5);
    if ((msg.id & 0x1F) == ODriveTeensyCAN::CMD_ID_ODRIVE_HEARTBEAT_MESSAGE) {
      HeartbeatMsg_t hb;
      odriveCAN.Heartbeat(hb, msg);
      if (hb.axisError != 0) {
        Serial.print("[ERROR] Axis "); Serial.print(node_id);
        Serial.print(": axisError = 0x"); Serial.println(hb.axisError, HEX);
        odriveCAN.RunState(node_id, 1); // Pone el eje en IDLE
      }
      if (hb.currentState != 8) { // Aquí va currentState, no axisState
        Serial.print("[ADVERTENCIA] Axis "); Serial.print(node_id);
        Serial.print(" fuera de Closed Loop. Estado: "); Serial.println(hb.currentState);
      }
    }
    // Agrega chequeos de otros mensajes aquí si lo necesitas
  }
}

void imprimirHeartbeats() {
  Serial.println("===== Heartbeats ODrive =====");
  for (int i = 0; i < num_motores; i++) {
    uint8_t node_id = motores[i].node_id;
    bool encontrado = false;
    unsigned long t0 = millis();
    while (millis() - t0 < 300) {
      CAN_message_t msg;
      if (odriveCAN.ReadMsg(msg)) {
        uint8_t id_msg = (msg.id >> 5);
        uint8_t cmd = (msg.id & 0x1F);
        if (id_msg == node_id && cmd == ODriveTeensyCAN::CMD_ID_ODRIVE_HEARTBEAT_MESSAGE) {
          // Acceso manual según documentación CANSimple
          uint32_t axisError;
          memcpy(&axisError, &msg.buf[0], 4);    // Bytes 0-3: axisError
          uint8_t axisState         = msg.buf[4]; // Byte 4: axisState
          uint8_t procedureResult   = msg.buf[5]; // Byte 5: procedureResult
          uint8_t trajectoryDone    = msg.buf[6]; // Byte 6: trajectoryDone

          Serial.print("Heartbeat Axis ");
          Serial.print(node_id);
          Serial.print(": axisError=0x"); Serial.print(axisError, HEX);
          Serial.print(", state="); Serial.print(axisState);
          Serial.print(", procedureResult="); Serial.print(procedureResult);
          Serial.print(", trajectoryDone="); Serial.println(trajectoryDone);
          encontrado = true;
          break;
        }
      }
    }
    if (!encontrado) {
      Serial.print("Heartbeat Axis ");
      Serial.print(node_id);
      Serial.println(": [NO RECIBIDO]");
    }
  }
  Serial.println("============================");
}


void mostrarSonrisa(){
  display.clearDisplay();
  display.drawBitmap(0,0,logo,128,64,WHITE);
  display.display();
}

void playMelody() {
  for (int i = 0; i < melodyLength; i++) {
    tone(BUZZER_PIN, melody[i], noteDurations[i]);
    delay(noteDurations[i] + 50);  // un pequeño espacio entre notas
    noTone(BUZZER_PIN);
  }
}
void playHighMelody() {
  for (int i = 0; i < melodyHighLength; i++) {
    tone(BUZZER_PIN, melodyHigh[i], noteDurationsHigh[i]);
    delay(noteDurationsHigh[i] + 20);  // breve pausa entre notas
    noTone(BUZZER_PIN);
  }
}
